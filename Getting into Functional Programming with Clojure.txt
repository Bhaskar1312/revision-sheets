Getting into Functional Programming with Clojure

Intro to the course
In this section, we kick-start our journey into Clojure, exploring the foundational aspects of the language. As you're presumably familiar with object-oriented languages like Java, C++, Ruby, or Python, you'll find some aspects of Clojure quite refreshing and new. However, no prior knowledge of Java, Lisp, or Clojure is required. This section sets the stage for you to feel comfortable with the basics, so you’re ready to build upon this knowledge in subsequent sections.

About Clojure
Clojure is a modern, dynamic, and functional dialect of the Lisp programming language on the Java platform. What makes Clojure special is its emphasis on immutability and its powerful concurrency support. Its popularity stems from its simplicity and the way it enables developers to write concise, expressive code. Some of the most significant features of Clojure include:

Immutability: Data structures are immutable by default, which leads to safer and more predictable code.
First-class functions: Functions are first-class citizens and can be passed around and manipulated just like any other data.
Concurrency: Provides robust support for concurrent programming with features like Software Transactional Memory (STM) and core.async.
Interoperability: Seamlessly integrates with Java, leveraging Java's comprehensive ecosystem.
You can learn more about Clojure at the official Clojure website. https://clojure.org/

Lisp Syntax
One of the first things you'll notice about Clojure is its distinctive syntax, which it inherits from Lisp. Here are some key points:

Parentheses: Clojure code is written in a series of nested lists, denoted by parentheses. For example:
(println "Hello, World!")

Infix vs. Prefix notation: Unlike many languages that use infix notation (e.g., 1 + 2), Clojure uses prefix notation where the operator comes before the operands, like so:

(+ 1 2 3)
(* 2 3 4)
(+ 1 (* 2 3))

Function Calls: In Clojure, function calls are written in the form of lists. The first element in the list is the function, and all the other elements are arguments. For instance, (+ 1 2) is a call to the + function with 1 and 2 as arguments. Similarly:
(println "Hello," "Clojure" "World!")
In this example, println is the function, and "Hello,", "Clojure", and "World!" are the arguments.

What You'll Learn
In this unit, you'll:

Become familiar with Lisp syntax and conventions.
Learn how to print messages to the console using println.
Perform basic arithmetic operations like addition and multiplication.
Define and work with variables using the def keyword.
Concatenate strings using str function
Write comments to document your code.

Here's a quick example to illustrate these points:

;; Game basics: printing messages, basic math, and defining variables

(println "Hello," "Clojure", "World!")

(def welcome-message "Welcome to the Clojure Shooter Game!")
(println welcome-message)

(def hero-score (+ 50 50 20)) ;; Adding score points, result is 120
(def villain-damage (* 2 25)) ;; Calculating damage, result is 50

;; More complex arithmetic operations
(def complex-calculation-1 (+ 20 (* 30 2))) ;; Result is 80
(def complex-calculation-2 (/ (+ 100 (* 5 2)) 2)) ;; Result is 55
(def complex-calculation-3 (- 200 (/ 50 2))) ;; Result is 175

;; String concatenation
;; println concatenates with space between, while str concatenates directly
(def concatenated-message (str "Your current score is " hero-score "!"))
(println concatenated-message)

Why It Matters
Understanding basic operations and how to define variables is crucial. These are the building blocks of programming in any language. Mastering these Clojure concepts will enable you to manipulate game elements such as scores, messages, and player statuses in our shooter game example. This knowledge forms the groundwork for everything else you'll encounter in Clojure, from controlling logic to handling data structures.

Ready to start coding? Let's move on to the practice section and solidify these concepts with hands-on exercises!



(println "Hello," "Clojure", "World!") ;; Outputs "Hello, Clojure World!" - println concatenates arguments with a space delimiter

(def welcome-message "Welcome to the Clojure Shooter Game!") ;; Variable definition
(println welcome-message) ;; Outputs "Welcome to the Clojure Shooter Game!"

(def hero-score (+ 50 50 20)) ;; Adding score points, result is 120
(def villain-damage (* 2 25)) ;; Calculating damage, result is 50

;; More complex arithmetic operations
(def complex-calculation-1 (+ 20 (* 30 2))) ;; Result is 80
(def complex-calculation-2 (/ (+ 100 (* 5 2)) 2)) ;; Result is 55
(def complex-calculation-3 (- 200 (/ 50 2))) ;; Result is 175

;; String concatenation
;; println concatenates with space between, while str concatenates directly
(def concatenated-message (str "Your current score is " hero-score "!"))
(println concatenated-message) ;; Outputs "Your current score is 120!"


Fundamental Data Types in Clojure
Welcome back! In the previous lesson, you learned the basics of the Clojure language, including how to print messages, perform basic arithmetic, and define variables. Now it’s time to dive a bit deeper into Clojure by exploring its fundamental data types. Just like knowing where to store and find items is crucial in a game, understanding data types is essential in programming.

What You'll Learn
In this lesson, we'll explore some fundamental Clojure data types. Specifically, we will touch upon:

Understanding and using nil values, which often represent emptiness or the lack of a value.
Working with Boolean values — specifically true and false — to manage game states.
Using characters and strings effectively, such as defining in-game messages.
Here's a quick look at what you’ll be able to do by the end of this lesson:

;; nil, truth, and falsehood, Characters and strings
(def ammo-count nil) ;; Out of ammo
(def is-hero-alive true)
(def is-villain-defeated false)
(def player-name-initial \B) ;; Characters are defined with a backslash and hold a single character
(def victory-message "Victory!")

(println "Ammo count:" ammo-count)
(println (str "Hero is alive: " is-hero-alive ", villain defeated: " is-villain-defeated))
(println "Player name initial:" player-name-initial)
(println victory-message)

Why It Matters
Understanding data types is vital because they allow us to store, manage, and manipulate data efficiently. In our Clojure shooter game, you'll need variables to keep track of whether your hero is alive, if the villain is defeated, the number of bullets left, and any game messages.

Determining if your hero is still alive or knowing when your ammo is depleted is crucial for developing functional game logic. Representing characters and messages ensures your game interacts effectively with players. These concepts form the backbone of game state management and are widely applicable in software development.

Ready to get your hands dirty? Let’s dive into the practice section and start leveraging these data types!

Welcome to Clojure Numbers
Welcome back! You've previously learned about the basics of Clojure and how to work with simple data types. Now, let's move forward and explore another important aspect of programming with Clojure: numbers. Understanding different types of numbers and how to manipulate them is key to managing various elements in our Clojure shooter game.

What You'll Learn
In this lesson, we will dive into the various types of numbers available in Clojure and how they interact with each other. Specifically, we will cover:

Different types of numbers such as Integers, Big Integers, Ratios, Big Decimals, and Floating Points.
How to mix and operate with different numeric types.
Handling arithmetic overflow and utilizing Clojure's auto-promotion capabilities to manage large numbers.
By the end of this lesson, you'll be comfortable handling numeric operations in Clojure, a skill that will allow you to manage game statistics, perform complex calculations, and much more.

Here's a quick look at some code you’ll be able to understand and write:

;; Different types of numbers
(def player-health 100) ;; Integer (Contagiousness 0 - Lowest)
(def max-health 100N) ;; Big Integer (Contagiousness 1)
(def damage-ratio 10/2) ;; Ratio (Contagiousness 2)
(def weapon-accuracy 0.8M) ;; Big Decimal (Contagiousness 3)
(def enemy-distance 20.5) ;; Floating Point (Contagiousness 4 - Highest)

;; Mixing numbers of different types
(def mixed-sum-1 (+ player-health max-health)) ;; Big Integer
(def mixed-sum-2 (+ player-health max-health damage-ratio)) ;; Ratio
(def mixed-sum-3 (+ player-health max-health damage-ratio weapon-accuracy)) ;; Big Decimal
(def mixed-sum-4 (+ player-health max-health damage-ratio weapon-accuracy enemy-distance)) ;; Floating Point

;; Overflow and auto-promoting to big integer
;; (def score-overflow (* 4037000499 3037000500)) ;; ArithmeticException integer overflow

(def auto-promoted-score (*' 4037000499 3037000500)) ;; Big Integer

Numeric Types in Clojure
Below is a table summarizing different numeric types in Clojure:

Type	Range and Implementation	Syntax Examples	Contagiousness
Integer	32-bit or 64-bit (platform dependent)	42, -7, 0	0 (Lowest)
Big Integer	Arbitrarily large and precise integers	42N, 1000N	1
Ratio	Infinite fractional numbers, stored as two big integers	3/4, 10/2	2
Big Decimal	Arbitrarily precise floating-point numbers	0.5M, 123.45M	3
Floating Point	64-bit IEEE 754 double-precision floating-point numbers	3.14, 1e-3	4 (Highest)
Contagiousness in this context refers to how operations involving mixed numeric types in Clojure will result in a type promotion to the "higher" type. For example, if you add an Integer and a Big Decimal, the result will be a Big Decimal because Big Decimal is more "contagious" (higher up in the hierarchy) than an Integer. The numerical types with higher contagiousness will impose their type on the result.

;; Different types of numbers
(def player-health 100) ;; Integer (Contagiousness: 0 - Lowest, Range: -2^63 to 2^63-1)
(def max-health 100N) ;; Big Integer (Contagiousness: 1, Range: Unlimited)
(def damage-ratio 1/2) ;; Ratio (Contagiousness: 2 - Medium, Range: Unlimited)
(def weapon-accuracy 0.8M) ;; Big Decimal (Contagiousness: 3, Range: Unlimited)
(def enemy-distance 20.5) ;; Floating Point (Contagiousness: 4 - Highest, Range: Approximately ±1.8 × 10^308)

;; Mixing numbers of different types
(def mixed-sum-1 (+ player-health max-health)) ;; Big Integer
(def mixed-sum-2 (+ player-health max-health damage-ratio)) ;; Ratio
(def mixed-sum-3 (+ player-health max-health damage-ratio weapon-accuracy)) ;; Big Decimal
(def mixed-sum-4 (+ player-health max-health damage-ratio weapon-accuracy enemy-distance)) ;; Floating Point

;; Print results
(println "Mixed sum 1:" mixed-sum-1) ;; Prints "Mixed sum 1: 200N"
(println "Mixed sum 2:" mixed-sum-2) ;; Prints "Mixed sum 2: 401/2"
(println "Mixed sum 3:" mixed-sum-3) ;; Prints "Mixed sum 3: 201.3M"
(println "Mixed sum 4:" mixed-sum-4) ;; Prints "Mixed sum 4: 221.8"


The provided code snippet shows how to handle arithmetic overflow using auto-promotion in Clojure. 
Typically, an arithmetic operation on integers can produce a result too large to represent as a Clojure integer—this is called overflow. 
Normally, when an overflow occurs, Clojure throws a java.lang.ArithmeticException. 
To prevent this and instead automatically promote the result to a Big Integer, Clojure offers alternative math functions: +', -', *', inc' (increment), and dec' (decrement). These functions are identical to their regular counterparts but include a single quote at the end.

Try playing with the code and uncomment the upper statement to see the ArithmeticException in action.
;; Overflow and auto-promoting to Big Integer
;; (def score-overflow (* 4037000499 3037000500)) ;; ArithmeticException integer overflow

(def auto-promoted-score (*' 4037000499 3037000500)) ;; Big Integer

(println "The auto-promoted score is:" auto-promoted-score)


Symbols and Keywords: An Exciting Journey
Welcome back! Having just reviewed the different types of numbers in Clojure, let's now dive into understanding symbols and keywords. Symbols and keywords are fundamental elements in Clojure that help with data labeling, function dispatch, and code readability. By mastering these, you will be able to create more readable and maintainable code, enhancing your overall programming efficiency.

What You'll Learn
In this lesson, you’ll discover:

Keywords in Clojure: How to create and use keywords using both shorthand and functions.
Symbols in Clojure: How to create and use symbols using both shorthand and functions.
Practical Examples: Concrete examples to show how symbols and keywords can be used efficiently in a shooter game context.
Keywords in Clojure are very similar to enums in other languages, providing a way to represent fixed sets of values. They are symbolic identifiers that evaluate to themselves and provide very fast equality tests. This makes them useful as "constant strings" for keys of a hash-map or dispatch values of a multimethod. This knowledge will allow you to better organize and manage game data, making your shooter game code cleaner and easier to understand. Keywords are often used in maps to structure data.

Symbols, on the other hand, are identifiers that are normally used to refer to something else, such as function parameters, let bindings, class names, and global vars. They are generally used to name variables and functions. It's less common to manipulate symbols as objects directly, except in macros and similar constructs. This is also the last scalar type we are going to discuss. Don’t worry if you don’t fully grasp them just yet; their utility will become more apparent as we dive deeper into Clojure.


;; Shooter Game Example

(def player-status :alive) ;; Creating a keyword using shorthand :
(def weapon-type (keyword "pistol")) ;; Creating a keyword using the keyword function

;; Print all defined keywords
(println "Keywords:")
(println (str "Player status: " player-status))
(println (str "Weapon type: " weapon-type))

;; Defining some values
(def player-name "John")
(def enemy-name "Doe")

(def player-symbol 'player-name) ;; Creating a symbol using the quote '
(def enemy-symbol (symbol "enemy-name")) ;; Creating a symbol using the symbol function

;; Print all defined symbols
(println "\nSymbols:")
(println (str "Player symbol (shorthand): " player-symbol))
(println (str "Enemy symbol (full syntax): " enemy-symbol))

;; Resolve symbols to their actual values
(println "\nResolving Symbols to Values:")
(println (str "Player name: " (eval player-symbol)))
(println (str "Enemy name: " (eval enemy-symbol)))

Why It Matters
Understanding symbols and keywords is critical for effective Clojure programming. They help you label and organize data, making your code more readable and maintainable. In the context of our shooter game:

Keywords are used to label certain states or types, aiding in function dispatch and improving code clarity.
Symbols are used to represent variables and other computational entities, which become essential when dealing with more complex data structures.
Mastering these will make your code cleaner and easier to debug. Imagine having a map that describes various game states and being able to instantly recognize each by its keyword or symbol. This will not only improve your ability to manage small scripts but also scale up to more complex applications.

Excited to level up your Clojure skills? Let's jump into the practice section and get our hands dirty with symbols and keywords!

Keywords are unique identifiers starting with a colon (:) to label values or entities. They are efficient for comparison and similar to enums in other languages. Keywords are also commonly used as keys in maps, which we'll cover later in subsequent courses. Example: :alive


Clojure Collections

Learning About Lists
Welcome to the first lesson of the "Clojure Collections" course. We'll start by exploring one of the most basic collection data structures: lists. Lists are fundamental data structures that allow you to organize and manipulate a series of elements. In this lesson, we'll focus on understanding and working with lists effectively.

What Are Lists?
Lists are a fundamental collection data structure in Clojure. If you’re familiar with other programming languages, Clojure lists are implemented as singly linked lists. In a singly linked list, each element, known as a node, holds a value and a reference (or link) to the next node in the sequence. This structure allows easy traversal from the first to the last element but does not support backward traversal. Consequently, adding or removing items is most efficient at the front of the list. While it is possible to add or remove items from the middle or end of the list, it is more time-consuming. However, due to their immutability, multiple lists can share the same tails, making them an efficient and simple immutable data structure.

Unlike some languages, including Java, lists in Clojure can contain elements of different types. This flexibility allows you to create lists with mixed data types, making them very versatile.

What You'll Learn
In this unit, you will learn how to create and manipulate lists in Clojure. We'll start by showing you how to define lists using two different syntaxes. Then, we'll explore how to add and remove items, check the list type, and count the elements in a list. Here's a sneak peek:

;; Creating lists
(def hero-inventory (list "pistol" "medkit" "ammo"))
(def hero-inventory-alt '("pistol" "medkit" "ammo")) ;; Alternative syntax

;; Adding items to the inventory
(def inventory-with-shield (conj hero-inventory "shield"))

;; Using inventory as a stack
(println "Peek at the top item in the inventory:" (peek hero-inventory))
(println "Pop the top item off the inventory:" (pop hero-inventory))

By the end of this lesson, you'll be comfortable working with lists in Clojure and equipped with the skills to manage your game data effectively.

Why It Matters
Lists are essential for managing collections of data. Whether you're keeping track of hero inventories in a shooter game, managing a to-do list, or storing a sequence of operations, lists provide a structured way to handle elements. Mastering lists will enable you to organize and process data more efficiently, making your Clojure programs more effective and easier to maintain.

Ready to enhance your Clojure skills? Let's dive into the practice section and learn how to wield lists like a pro!

To summarize:

Creating Lists:

Use (list "item1" "item2" "item3") or '( "item1" "item2" "item3") to create lists.
Checking the List Type:

Use (list? your-list) to check if a given collection is a list.
Adding Items:

Use (conj your-list "new-item") to add an item to the head (beginning) of the list.
You can also add multiple items at once using (conj your-list "item1" "item2").
Using Lists as Stacks:

Use (peek your-list) to look at the first item in the list (stack style).
Use (pop your-list) to return the list without the first item.
Handling Empty Lists:

You can safely peek an empty list, which will return nil, but trying to pop an empty list will cause an error.
Counting Elements:

Use (count your-list) to count the number of items in the list.


;; Working with lists in a shooter game

;; Creating lists
(def hero-inventory (list "pistol" "medkit" "ammo"))
(def hero-inventory-alt '("pistol" "medkit" "ammo")) ;; Alternative syntax
(println "Hero's inventory:" hero-inventory)
(println "Hero's inventory (alternative syntax):" hero-inventory-alt)

;; Checking if a collection is a list
(println "Is hero-inventory a list?" (list? hero-inventory))

;; Adding items to the inventory (conj adds to the beginning of the list)
(def inventory-with-shield (conj hero-inventory "shield"))
(def inventory-with-multiple (conj hero-inventory "shield" "grenade" "armor"))
(println "Inventory after adding one item:" inventory-with-shield)
(println "Inventory after adding multiple items:" inventory-with-multiple)

;; Using inventory as a stack
(println "Peek at the top item in the inventory:" (peek hero-inventory))
(println "Pop the top item off the inventory:" (pop hero-inventory))

;; Peeking and popping an empty list
(println "Peek at an empty list:" (peek '()))
;(println "Pop an empty list:" (pop '())) ;; will cause an error, uncomment to see it in action

;; Counting the items in the inventory
(println "Number of items in the inventory:" (count hero-inventory))



;; TODO: Add the items "torch" and "rope" to hero-inventory and save the result in updated-inventory
(def updated-inventory (conj  hero-inventory "torch" "rope"))

;; TODO: Print the first element of updated-inventory using the peek function
(println (peek updated-inventory))

;; TODO: Remove the first element from updated-inventory using pop and save the result in final-inventory
(def final-inventory (pop updated-inventory))


Working with Vectors
Welcome back! In this lesson, we'll be exploring another fundamental data structure in Clojure: vectors. After diving into lists in the previous lesson, you might feel comfortable with some basic collection operations. Now, let's take that understanding further by focusing on vectors, which offer different advantages and functionalities.

Understanding Vectors
Vectors in Clojure are similar to lists, but with some key differences. The primary distinction is that vectors are indexed by numbers, which allows for fast random access to their elements. This indexing means you can quickly retrieve or update an element at any position without having to traverse the entire collection. In contrast, lists are optimized for sequential access, making vectors more suitable for scenarios where you need efficient access to elements by their position.

What You'll Learn
In this unit, you'll learn how to define and manipulate vectors in Clojure. We’ll cover how to quickly access elements, modify the content, and use core functions like get, nth, assoc, and conj. We'll also look at how vectors can be used in various game development scenarios. Here's a sneak peek of what you'll be doing:

;; Defining vectors
(def hero-stats ["health" 100 "score" 5000])
(def inventory-vector (vector "pistol" "medkit" "ammo"))

;; Fast random access to elements using get and nth
(println "Health:" (get hero-stats 1))
(println "Score:" (nth hero-stats 3))

;; Modifying vectors
(def updated-stats (assoc hero-stats 1 90))
(def extended-inventory (conj inventory-vector "shield"))

;; Using peek and pop with vectors
(println "Peek at the last item in inventory:" (peek inventory-vector))
(println "Pop the last item off the inventory:" (pop inventory-vector))

By the end of this lesson, you'll be able to efficiently manage and manipulate vectors to better handle your game's data and various other practical applications.

Why It Matters
Understanding how to work with vectors is crucial for managing game data or any other structured information efficiently. Vectors provide fast random access to their elements and support easy modifications, making them suitable for scenarios where performance is critical — like updating player stats or inventory in games. Mastering vectors will make your Clojure programs more efficient and capable of handling complex data structures.

Excited to enhance your data management skills? Let's jump into the practice section and see how powerful vectors can be in action!

Creating Vectors:

Use (vector "item1" "item2" "item3") or ["item1" "item2" "item3"] to create vectors.
Accessing Elements:

Use (nth your-vector index) to access an element at a specific index. An invalid index will cause an error.
Use (get your-vector index) to access an element at a specific index, with an optional default value if the index is out of bounds, e.g., (get your-vector 10 "default-value").
You can also treat the vector as a function to access elements: (your-vector index). An invalid index will cause an error.
Modifying Vectors:

Use (assoc your-vector index new-value) to update an element at a specific index. An invalid index will cause an error.
Use (conj your-vector "new-item") to add an element to the end of the vector.
Using Peek and Pop:

Use (peek your-vector) to look at the last item in the vector.
Use (pop your-vector) to remove the last item from the vector.
Note that trying to pop an empty vector will cause an error.

;; Working with vectors in a shooter game

;; Defining vectors
(def hero-stats ["health" 100 "score" 5000])
(def inventory-vector (vector "pistol" "medkit" "ammo"))
(println "Hero stats:" hero-stats)
(println "Hero's inventory:" inventory-vector)

;; Fast random access to elements using get and nth
(println "Health:" (get hero-stats 1))
(println "Score:" (nth hero-stats 3))
(println "Accessing non-existing index with get:" (get hero-stats 10 "not-found"))
;; (println "Accessing non-existing index with nth:" (nth hero-stats 10)) ;; will cause an error to demonstrate safe and unsafe operations

;; Vectors as functions
(println "Access using vector as a function:" (hero-stats 1))

;; Modifying vectors
(def updated-stats (assoc hero-stats 1 90))
(println "Updated stats:" updated-stats)
;; (def incorrect-update (assoc hero-stats 10 90)) ;; will cause an error to demonstrate safe updates

(def extended-inventory (conj inventory-vector "shield"))
(println "Extended inventory:" extended-inventory) ;; conj adds to the end of vector

;; Using peek and pop with vectors
(println "Peek at the last item in inventory:" (peek inventory-vector))
(println "Pop the last item off the inventory:" (pop inventory-vector))

;; Peeking and popping empty vectors
(println "Peek at an empty vector:" (peek []))
;; (println "Pop an empty vector:" (pop [])) ;; will cause an error to demonstrate handling empty collections

Using get function: Retrieves an element at a given index.

Clojure
(get my-vector index)
(get my-vector index default-value)
If the index is out of bounds, it returns nil or a specified default value.
Using nth function: Retrieves an element at a given index.

Clojure
(nth my-vector index)
If the index is out of bounds, it throws an IndexOutOfBoundsException.
Using vector as a function: Vectors can be used as functions themselves to access their elements.

Clojure
(my-vector index)
If the index is out of bounds, it throws an IndexOutOfBoundsException.
Warning: Be mindful of indices that are out of bounds, especially for methods that can throw an error.


Learning About Maps
Welcome back! In our journey through Clojure collections, we've already tackled lists and vectors. Now, we are stepping into another essential data structure: maps. Previously, we learned about vectors and their efficiency for random access and organizing game data. In this lesson, we'll explore what maps bring to the table and how they can make your code more intuitive and efficient.

What Are Maps
Maps are similar to associative arrays or dictionaries in languages like Python, Ruby, and Perl. A map is a collection of key-value pairs. In Clojure, keys can be of various types, including keywords, strings, symbols, and numbers. The keys must be immutable and implement proper hash and equals functions to ensure efficient and reliable lookups.

There are two main types of maps in Clojure: hashmaps and sorted maps. Hashmaps use hash functions to quickly locate values associated with a given key, making lookups near constant time, O(1). Sorted maps maintain their keys in a sorted order, allowing efficient range queries but generally having slower access times compared to hashmaps, typically O(log n).

In this lesson, we will focus exclusively on hashmaps, as they are more widely used and offer efficient key-value retrieval for most scenarios.

What You'll Learn
In this unit, you'll learn to define and manipulate maps in Clojure. We'll cover how to quickly access values, modify maps, and manage key-value pairs using core functions like get, assoc, and dissoc. You'll find maps particularly useful in scenarios requiring descriptive, easy-to-read code, such as managing game states. Here's a glimpse of what you will be doing:
;; Defining maps
(def game-state {:hero "ready" :villain "approaching"})
(def alternative-syntax (hash-map :hero "ready" :villain "approaching"))
(println "Game state:" game-state)

;; Fast access to map values
(println "Hero status:" (get game-state :hero))
(println "Villain status:" (game-state :villain))

;; Modifying maps
(def updated-game-state (assoc game-state :villain "defeated"))
(println "Updated game state:" updated-game-state)

By the end of this lesson, you'll be adept at managing maps to organize game states or other meaningful data structures effectively.

Why It Matters
Mastering maps is crucial for creating clear and efficient Clojure programs. Maps offer a straightforward way to store and retrieve data using key-value pairs, enabling you to write clean, maintainable code. This is particularly important when managing complex game states or any scenario where attributes need to be quickly and accurately accessed or updated. Understanding maps will not only improve your coding efficiency but will also make your programs easier to understand and extend.

Feeling ready to take your coding abilities to the next level? Let's dive into the practice section and see how maps can empower your Clojure programming experience!

Creating Maps:

Use {:key1 "value1" :key2 "value2"} to create a map.
Alternatively, use (hash-map :key1 "value1" :key2 "value2") for the same result.
Note: We are using keywords as keys for the HashMap hence the syntax :key, otherwise the : is not necessary.
Accessing Values:

Use (get your-map :key) to access a value by its key.
You can also access a value using the map as a function: (your-map :key).
If the key does not exist, (get your-map :non-existent "default-value") provides a way to return a default value.
Check for Key Existence:

Use (contains? your-map :key) to check if a key exists in the map.
Modifying Maps:

Use (assoc your-map :key "new-value") to add or update a key-value pair.
Deleting Keys:

Use (dissoc your-map :key) to remove a key-value pair from the map.
You can also remove multiple key-value pairs using (dissoc your-map :key1 :key2).


Exploring Nested Maps
Welcome! As you build your skills in Clojure collections, you've already conquered the basics of lists, vectors, and maps. Now, we're going to delve deeper into a more complex yet powerful concept: nested maps. This lesson builds upon the map fundamentals, so keep in mind it's a continuation of what you already know about maps.

What You'll Learn
In this lesson, you'll master the art of working with nested maps in Clojure. Nested maps are essentially maps within maps and are extremely useful for representing structured data. We'll cover how to define nested maps, access their deeply nested values, update them efficiently, and even delete nested keys. Below is a quick snippet of what you're going to work with:

;; Defining nested maps
(def nested-state {:hero {:health 100 :ammo 5} :villain {:health 50}})
(println "Nested state:" nested-state)

;; Accessing nested map values
(println "Hero's health:" (get-in nested-state [:hero :health]))

;; Updating nested maps
(def updated-nested-state (assoc-in nested-state [:hero :ammo] 10))
(println "Updated nested state:" updated-nested-state)

;; Deleting nested values
(def cleaned-nested-state (update nested-state :hero dissoc :ammo))
(println "Nested state after deleting hero's ammo:" cleaned-nested-state)

By the end of this lesson, you’ll be equipped to manage more complex data relationships effortlessly

Why It Matters
Understanding and using nested maps is crucial for scenarios where data is hierarchically structured — such as complex game states. By mastering nested maps, you can create more organized, readable, and maintainable code. For instance, in a game, you might need to manage intricate details about characters, inventory, and world state — all of which can be effectively stored and manipulated using nested maps. This skill not only enhances your ability to handle complex data but also makes your programs more efficient and easier to understand.

Excited to dive deeper? Let's start the practice section and see how mastering nested maps can sharpen your Clojure programming skills!

Creating Nested Maps:

Use {:key1 {:subkey1 "value1" :subkey2 "value2"} :key2 {:subkey3 "value3"}} to create nested maps.
Alternatively, you can create nested maps using the hash-map function, although it is less concise: (hash-map :key1 (hash-map :subkey1 "value1" :subkey2 "value2") :key2 (hash-map :subkey3 "value3")).
Accessing Elements:

Use (get-in your-map [:key1 :subkey1]) to access an element within nested maps.
Alternatively, you can use multiple get functions: (get (get your-map :key1) :subkey1).
Modifying Nested Maps:

Use (assoc-in your-map [:key1 :subkey1] "new-value") to update an element within nested maps.
Deleting Elements:

Use (update your-map :key1 dissoc :subkey1) to remove a key from a nested map.

Using get-in function: This function is specifically designed for nested maps and retrieves the value associated with a sequence of keys.

Clojure
(get-in my-map [key1 key2])
(get-in my-map [key1 key2] default-value)
If the nested key does not exist in the map, it returns nil or a specified default value.
Using nested map access with get and keywords: These methods are the same as for usual maps and can be chained to access nested values.

Clojure
(get (get my-map key1) key2)
(:key2 (get my-map key1))
Using map as a function on nested maps: Again, map usage as functions is the same as for usual maps and can be chained to access nested values.

Clojure
((my-map key1) key2)
((my-map key1) :key2)
Your task is to retrieve and print certain values from a nested map using these different methods.

assoc-in: The assoc-in function updates a value in a nested map. It returns a new map with the specified change, leaving the original map unscathed.

Syntax: (assoc-in map [keys...] value)
Example: (assoc-in {:a {:b {:c 1}}} [:a :b :c] 2) results in {:a {:b {:c 2}}}
update-in: The update-in function updates a value in a nested map using a function. Like assoc-in, it produces a new map.

Syntax: (update-in map [keys...] f & args)
Example: (update-in {:a {:b {:c 1}}} [:a :b :c] dec) results in {:a {:b {:c 0}}}
Note: The dec function decrements a number by one. For example, (dec 10) results in 9.

update-in: The update-in function updates a value in a nested associative structure by applying a function to it. To delete a key, we can use update-in in combination with dissoc.

Syntax: (update-in map [nested-keys] dissoc nested-key)

Example: (update-in {:a {:b {:c 1}}} [:a :b] dissoc :c) results in {:a {:b {}}}

Example (Removing multiple values): You can chain multiple update-in calls to remove multiple values.

Clojure

(-> {:a {:b {:c 1 :d 2}}}
    (update-in [:a :b] dissoc :c)
    (update-in [:a :b] dissoc :d))
This results in {:a {:b {}}}

Example (Deleting keys of greater depth): You can use update-in to remove keys at deeper levels in the map.

Clojure

(-> {:a {:b {:c {:d 1 :e 2}}}}
    (update-in [:a :b :c] dissoc :d)
    (update-in [:a :b :c] dissoc :e))
This results in {:a {:b {:c {}}}}.

;; TODO: Create a nested map representing game characters with hero and villain, 
;; including their attributes of strength, and inventory including sword and shield.
;; Desired map in JSON:
;; {
;;   "hero": {
;;     "attributes": {
;;       "strength": 80
;;     },
;;     "inventory": {
;;       "sword": "Steel"
;;     }
;;   },
;;   "villain": {
;;     "attributes": {
;;       "strength": 90
;;     },
;;     "inventory": {
;;       "sword": "Dark Blade",
;;       "shield": "Dark Shield"
;;     }
;;   }
;; }

;; TODO: Print the initial game characters nested map.
(def game-characters { :hero {:attributes {:strength 80} :inventory {:sword "Steel"}} 
:villain {:attributes {:strength 90} :inventory {:sword "Dark Blade" :shield "Dark Shield"}}})
(println game-characters)

;; TODO: Add the key-value pair :health 100 to hero's attributes and store the result in updated-game-characters.
(def updated-game-characters (assoc-in game-characters [:hero :attributes :health] 100))

;; TODO: Print the updated game characters nested map with health added to hero.
(println updated-game-characters)

;; TODO: Read the hero's strength attribute and print it.
(println (get-in updated-game-characters [:hero :attributes :strength]))

;; TODO: Read the villain's non-existent :armor attribute with a default value of "None" and print it.
(println (get-in updated-game-characters [:hero :attributes :armor] "None"))

;; TODO: Delete the key :shield from the villain's inventory and store the result in cleaned-game-characters.
(def cleaned-game-characters (update-in updated-game-characters [:villain :inventory] dissoc :shield))
(println cleaned-game-characters)

;; TODO: Print the game characters nested map without the villain's shield.


Introduction to Sets
Welcome back! Now that we've covered nested maps, you're familiar with handling more complex data structures in Clojure. Our next stop is an equally important collection type: Sets. This lesson will show you how to define, manipulate, and query sets in Clojure. You will see how sets differ from other collections and discover their unique advantages in efficiently managing unique elements.

What are Sets?
Sets are collections that store unique elements. Unlike lists or vectors, sets do not allow duplicate entries—if you try to add a duplicate element, it will simply be ignored. Sets do not maintain the order of elements. They are particularly useful for scenarios where you want to maintain a collection of distinct items and perform efficient membership checks. Internally, sets use a hash function, which allows for very fast checking of whether an element is in the set. For example, in our shooter game analogy, you can use sets to keep track of unique skills a character has in a game or to manage a list of unique email addresses.

What You'll Learn
In this lesson, you will learn:

Defining Sets: We'll start by understanding how to create sets using literal and function-based syntax.
Manipulating Sets: You'll see how to add and remove elements from sets, ensuring all elements remain unique.
Querying Sets: We'll cover how to check for element membership, a key aspect of set usage.
Here's a quick preview of what we'll be working with:

;; Defining sets
(def hero-abilities #{"strength" "agility" "intelligence"})
(def alternative-syntax (hash-set "strength" "agility" "intelligence"))
(println "Hero abilities:" hero-abilities)
(println "Hero abilities (alternative syntax):" alternative-syntax)

;; Adding elements to sets
(def abilities-with-speed (conj hero-abilities "speed"))
(println "Abilities after adding speed:" abilities-with-speed)

;; Demonstrating adding an existing element to sets
(def abilities-with-duplicate-element (conj hero-abilities "strength"))
(println "Abilities after adding an existing element 'strength':" abilities-with-duplicate-element)

;; Removing elements from sets
(def abilities-without-agility (disj hero-abilities "agility"))
(println "Abilities after removing agility:" abilities-without-agility)

;; Checking membership in sets
(println "Does hero have strength?" (contains? hero-abilities "strength"))
(println "Does hero have speed?" (contains? hero-abilities "speed"))

By the end of this lesson, you'll be comfortable working with sets and applying these techniques in your projects.

Why It Matters
Understanding sets is vital for scenarios involving collections of unique items. For instance, in a game, a character might have a set of unique abilities that should not repeat. Sets ensure that any item is stored only once, providing an efficient means to check for the existence of an item. This not only simplifies your code but also optimizes performance when working with collections.

Excited to add another powerful tool to your Clojure skill set? Let's dive into the practice section and explore the fascinating world of sets!

Here are the key concepts:

Creating Sets:

Use (hash-set "item1" "item2" "item3") or #{"item1" "item2" "item3"} to create sets.
Adding Elements:

Use (conj your-set "new-item") to add an element to the set, ensuring no duplicates.
Removing Elements:

Use (disj your-set "item-to-remove") to remove an element from the set.
Checking Membership:

Use (contains? your-set "item") to check if an element is in the set.

contains?: The contains? function checks if a collection (like a set) contains a particular key (or element).

Syntax: (contains? set element)
Example: (contains? #{"a" "b" "c"} "a") returns true
Note: contains? works efficiently with sets and maps.

Exploring Sequences
Welcome back! You've done a fantastic job learning about various collection types like lists, vectors, maps, and sets in Clojure. Now, we're about to dive into sequences — a fundamental concept that ties these collections together. In this lesson, you'll learn how to work with sequences across different collection types, enabling you to process and manipulate data more efficiently. Ready to get started?

Understanding Sequence
A sequence isn’t a collection type. Rather, a sequence is an interface (called ISeq) that exposes a “one thing followed by more things” abstraction. This interface is widely adopted by Clojure’s data structures. Additionally, many functions and macros in Clojure are designed to work seamlessly with sequences. The sequence abstraction allows all data structures to look and act like lists, even if the underlying values are some other collection type (such as a vector or hash map) or are even created lazily as they’re needed.

Here are some key functions provided by the sequence interface:

first coll: Returns the first element of the sequence, similar to how peek works for lists, but it operates consistently across all collection types.
rest coll: Returns the sequence without the first element, functioning similarly to pop for lists. If there are no more elements in the collection, it returns an empty sequence rather than throwing an exception.
cons elem coll: Short for "construct", this function creates new sequences by adding an element to the beginning of an existing sequence. The original sequence becomes the “tail” of the new sequence.

Laziness of Sequences
Note that the sequence abstraction is usually lazy, meaning that functions like first, rest, and cons don’t do extra work to create lists, even though the result prints like a list (that is, surrounded by parentheses).

The sequence abstraction allows everything to seem as though real lists were being manipulated but avoids actually creating any new data structures (such as actual lists) or doing any unnecessary work (such as creating items farther down the sequence that are never used).

What You'll Learn
Sequences in Clojure are a powerful way to traverse and manipulate collections. In this lesson, you'll explore:

Accessing Elements: How to retrieve elements from lists, vectors, maps, and sets using sequence functions like first and rest.
Modifying Collections: Learn to add elements to collections using cons effectively.
Consistency Across Collections: Understand the similarities in handling different collection types through sequences.
Here’s a preview of what you will be working with:
;; Lists
(def hero-gear '("pistol" "medkit" "ammo"))
(println "First item in hero-gear (list):" (first hero-gear))
(println "Rest of hero-gear (list):" (rest hero-gear))
(println "Adding an item to hero-gear (list) with cons:" (cons "shield" hero-gear))

;; Vectors
(def hero-stats ["health" 100 "score" 5000])
(println "First item in hero-stats (vector):" (first hero-stats))
(println "Rest of hero-stats (vector):" (rest hero-stats))
(println "Adding an item to hero-stats (vector) with cons:" (cons "level" hero-stats))

Why It Matters
Sequences provide a uniform way to access and manipulate different collection types in Clojure. This simplifies your code and makes it more readable, as you can use the same functions across lists, vectors, maps, and sets. Whether you're managing game items or player stats, sequences enable you to efficiently traverse and modify your data structures. This knowledge is crucial for writing more powerful and maintainable Clojure code.

Excited to see the magic of sequences in action? Let's proceed to the practice section and enhance your skills together!

Here are the key operations:

Getting the First Element:

Use (first your-collection) to get the first element of the collection.
Note: For sets and maps, first does not guarantee any specific element because they are unordered collections.
Getting the Rest of Elements:

Use (rest your-collection) to get all elements except the first one.
Note: For sets and maps, rest does not guarantee any specific order of elements because they are unordered collections.
Adding an Element:

Use (cons new-element your-collection) to add an element to the front of the collection for lists, vectors, and maps (though conj and assoc are often more appropriate for vectors and maps).
cons adds an item to the beginning of a sequence, with the original sequence becoming the “tail” of the new sequence. However, it is important to understand that cons does not create a new data structure. The sequence abstraction it uses allows it to act as though all sequential structures it touches are list-like without actually creating any new data structures or doing unnecessary work.

;; Working with sequences in a shooter game using different collection types

;; Lists
(println "Lists:")
(def hero-gear '("pistol" "medkit" "ammo"))
(println "First item in hero-gear (list):" (first hero-gear))
(println "Rest of hero-gear (list):" (rest hero-gear))
(println "Adding an item to hero-gear (list) with cons:" (cons "shield" hero-gear))

;; Vectors
(println "\nVectors:")
(def hero-stats ["health" 100 "score" 5000])
(println "First item in hero-stats (vector):" (first hero-stats))
(println "Rest of hero-stats (vector):" (rest hero-stats))
(println "Adding an item to hero-stats (vector) with cons:" (cons "level" hero-stats))

;; Maps
(println "\nMaps:")
(def game-state {:hero "ready" :villain "approaching"})
(println "First key-value pair in game-state (map):" (first game-state))
(println "Rest of key-value pairs in game-state (map):" (rest game-state))
(println "Adding a key-value pair to game-state (map) with cons:" (cons [:level 1] game-state))

;; Sets
(println "\nSets:")
(def hero-abilities #{"strength" "agility" "intelligence"})
(println "First item in hero-abilities (set):" (first hero-abilities))
(println "Rest of hero-abilities (set):" (rest hero-abilities))
(println "Adding an item to hero-abilities (set) with cons:" (cons "speed" hero-abilities))

Unlocking the Power of Functions
Welcome back! In this lesson, we are taking a big leap forward by learning how to define and use functions in Clojure. Functions are at the heart of any program and are key to writing clean, reusable, and well-organized code. You’ve encountered some basic concepts in previous lessons, but now we’ll explore functions in more depth. Ready to get started?

Functions in Clojure
Clojure is a functional programming language, which fundamentally revolves around the concept of functions. In Clojure, functions are considered first-class citizens. But what does that mean?

Being first-class citizens means functions in Clojure can:

Be Created Dynamically: You can define functions on-the-fly while your program is running.
Be Passed as Arguments: Functions can be passed as arguments to other functions.
Be Returned from Other Functions: Functions can return other functions as their result.
Be Stored as Values: Functions can be stored inside data structures like maps, vectors, and lists.
These capabilities provide immense flexibility and power. If you have a background in languages like C++ or Java, this might be a new way of thinking for you.

Understanding this will give you a solid foundation for leveraging the full potential of Clojure. Let's see how to harness this power by defining and using Clojure functions.

What You'll Learn
We'll explore various ways to define and use functions in Clojure. Here’s a sneak peek at what you'll learn:

Defining Functions Using a Combination of def and fn Macro: How to create functions with the combination of def and fn.
Defining Functions Using defn Macro: How to use the defn macro for defining functions more concisely.
Calling Functions: How to call functions to execute the code within.
For instance, you’ll learn to define a basic function like this:
(defn game-start []
  (println "Game Started! Prepare for battle!"))
(game-start)
And how to create a function that takes arguments:
(defn greet [name]
  (str "Greetings, " name "!"))
(println (greet "Captain Lambda"))

Why It Matters
Understanding functions is crucial because they help you break down complex tasks into smaller, manageable pieces. This makes your code easier to read, test, and maintain. Functions are reusable, so you can call the same code multiple times without rewriting it. Whether you are managing game mechanics or creating efficient data processing pipelines, mastering functions will make you a more effective programmer.

Excited? Let’s dive in and master Clojure functions together.

In Clojure, there are multiple ways to define a function. The two most common methods are using def with fn and using defn.

Using def and fn:

def is used to define a variable and fn is used to create an anonymous function.
(def greet (fn [name] (str "Hello, " name "!")))
(println (greet "Captain Lambda"))

Using defn:

defn combines the functionality of def and fn, making it more concise.
(defn greet [name]
  (str "Hello, " name "!"))
(println (greet "Captain Lambda"))

You can call functions by simply using their names followed by arguments (if any) in parentheses. Functions can return various values based on their implementation, and the return value is the result of the last expression executed within the function body.

Embracing Multi-Arity Functions
Hello again! Now that you've gotten a solid grounding in defining functions, let's dive into an exciting new aspect: multi-arity functions. This term might sound complex, but it's simple once you understand it. We're going to build on your knowledge of functions and explore how to make our functions more flexible and powerful.

What is Multi-Arity Functions?
The arity of a function refers to the number of parameters it accepts. In Clojure, functions can be defined to handle different numbers of arguments, a concept known as multi-arity. Put simply, you can create a single function that offers multiple 'overloaded' versions depending on the number of arguments passed to it. This is quite similar to function overloading in other programming languages.

Here’s how you can define a function with multiple arities in Clojure:
(defn example-function
  ([] 
   (println "Zero parameters"))
  ([param1]
   (println "One parameter:" param1))
  ([param1 param2]
   (println "Two parameters:" param1 param2)))

(example-function) ;; Output: Zero parameters
(example-function "A") ;; Output: One parameter: A
(example-function "A" "B") ;; Output: Two parameters: A B

In this example, example-function can be called with either zero, one, or two arguments, allowing you to handle different scenarios with a single function name.

What You'll Learn
In this lesson, we'll focus on multi-arity functions by demonstrating how to define a function that can handle different numbers of arguments within the same definition. This flexibility makes your functions incredibly versatile.

Here's an example function that calculates damage in four different ways:
(defn total-damage
  ([] 
   0)
  ([base-damage] 
   base-damage)
  ([base-damage weapon-multiplier] 
   (* base-damage weapon-multiplier))
  ([base-damage weapon-multiplier additional-multiplier]
   (+ (* base-damage weapon-multiplier) (* base-damage additional-multiplier))))

(total-damage) ;; => 0
(total-damage 10) ;; => 10
(total-damage 10 2) ;; => 20
(total-damage 10 2 3) ;; => 50

In this example:

No arguments return a default damage of 0.
A single argument calculates the base damage.
Two arguments calculate the damage with a weapon multiplier.
Three arguments calculate the damage with both a weapon multiplier and an additional multiplier.

Why It Matters
Understanding and implementing multi-arity functions will enhance your code’s reusability and efficiency. Instead of writing separate functions for different numbers of arguments, you can use one adaptable function. This makes your code cleaner and easier to maintain.

Ready to tackle this exciting challenge? Let's head to the practice section and deepen your understanding together!


Introduction
Welcome back! You've already learned the basics of defining functions in Clojure and explored variable arity. Now, let's expand your knowledge even further by diving into variadic functions. This topic will offer you even more flexibility in handling functions with an indefinite number of arguments. Imagine being able to pass any number of inputs to your function and have it correctly process them all. Sounds powerful, right? Let's explore this fascinating aspect of Clojure programming.

What Are Variadic Functions?
A variadic function is a function that can accept a variable number of arguments. Different programming languages have various ways to support this feature. In Clojure, you can declare a variadic function using the & symbol. This allows you to bundle multiple arguments into a single collection.

For example:
(defn count-all-elements [& elements]
  (count elements))

;; Usage
(println "Number of elements in the list:" (count-all-elements 1 2 3)) ; => Number of elements in the list: 3
(println "Number of elements in the list:" (count-all-elements "a" "b" "c" "d" "e")) ; => Number of elements in the list: 5
In the above function, count-all-elements can be called with any number of arguments. All the provided arguments are grouped into a single list called elements, which the function can then process.

The function uses the count function to count the number of elements. So, (count elements) will return the number of elements in the elements list.

What You'll Learn
In this lesson, we'll focus on variadic functions. Variadic functions allow you to write functions that accept a flexible number of arguments. Here’s a quick outline of what we’ll cover:

Definition of a Variadic Function: How to declare a function that takes a variable number of arguments.
Handling Multiple Arguments: Using the & symbol to manage multiple inputs.
Practical Examples: Implementing a function to calculate the total score from multiple mission scores.
Here's a quick preview:
(defn calculate-total-score [& mission-scores]
  (apply + mission-scores))
(println "Total score for missions:" (calculate-total-score 100 200 150)) 
;; Total score for missions: 450

Why It Matters
Mastering variadic functions will enhance your ability to write flexible and robust code. This is especially useful in scenarios where the number of inputs can vary, such as calculating game scores or metrics from various conditions and inputs.

Excited to dive into this empowering feature of Clojure? Let's proceed to the practice section and refine your skills in handling multiple arguments efficiently.


Introducing the let Form
Welcome back! You've already covered how to define functions, handle multiple arity, and work with variadic functions in Clojure. We're now ready to explore another vital aspect of Clojure programming: the let form. Imagine having a robust way to manage local bindings within your functions, making your code cleaner and easier to understand. That's what you'll achieve by mastering the let form.

What Is The let Form?
Consider the following function that calculates a complex formula:
(defn complex-calculation []
  (/ (+ 10 (* 3 20) (- 15 5) (/ 25 5)) 4))
Observe that the body of the function is quite complex. The let form allows you to introduce local bindings, making the code more readable and maintainable. Here’s an improved version using let:

(defn complex-calculation []
  (let [part1 (+ 10 (* 3 20))
        part2 (- 15 5)
        part3 (/ 25 5)
        total (+ part1 part2 part3)]
    (/ total 4)))
    
In this version, part1, part2, part3, and total are local bindings that help break down the complex computation into simpler, more understandable parts. These bindings exist only within the scope of the let form.

What You'll Learn
In this lesson, we'll focus on the let form. The let form allows you to create local bindings inside a function, which helps in organizing and modularizing your code. In this unit, we'll cover:

Defining Local Variables: How to declare local bindings within a function.
Using the let Form Effectively: Employing let to manage intermediate computations and maintain clean and readable code.
The Underscore Identifier: Understand how to use the underscore (_) identifier effectively in let bindings.
Practical Examples: Implementing a function to calculate a hero's effective attack power in a role-playing game.
Here’s a quick look at what this looks like in Clojure:

(defn effective-attack-power [base-power weapon-bonus]
  (let [difficulty-level 2
        power-multiplier 1.5
        effective-power (* base-power weapon-bonus power-multiplier difficulty-level)]
    (println "Effective attack power is: " effective-power)
    effective-power))
;; Example call to the function
(effective-attack-power 10 1.2) ;; Effective attack power is: 36.0

Why It Matters
Understanding the let form is essential for writing more organized and maintainable code. By using local bindings, you can break down complex calculations into simpler, more readable parts. This practice is especially useful in scenarios like game development, where multiple factors influence the final result.

Ready to make your Clojure code cleaner and more efficient? Let’s dive into the practice section and master the art of using local bindings with the let form.

The _ identifier is a convention in Clojure (and many other languages) for an unused or ignored value. It is often used when you need to destructure or bind a value you don't need later in your code. It is also commonly used for side effects like printing or logging.
Here is a quick example of using _ in a let form:

(let [_ (println "This is a side effect")
      binding-form value]
  body)
  
In the let form, the underscore _ is used as a placeholder to ignore the result of (println "Calculating effective attack power..."). This means the function will print "Calculating effective attack power..." to the console but won't assign the result to any variable

Overview of Function Meta Information and Documentation
Welcome back! You've been learning how to define functions, handle multiple arity, and work with variadic functions in Clojure. Now, you're ready to explore an important aspect of writing well-documented and maintainable code: function meta information and documentation. This lesson will show you how to add meaningful descriptions and metadata to your functions, making your code easier to understand and collaborate on.

What You'll Learn
In this lesson, we'll focus on two key aspects:

Docstrings: You'll learn how to add inline documentation to your functions, helping future you (and others) understand what the function does.
Metadata Maps: You'll discover how to enrich your functions with additional metadata such as version information, author information, and more.
These techniques are fundamental for writing clear and maintainable Clojure code. Here’s a quick overview with examples:

Using Docstrings
Docstrings are a great way to add brief descriptions directly inside your functions:
(defn calculate-hero-damage
  "Calculates hero's damage output."
  [base-damage critical-multiplier]
  (* base-damage critical-multiplier))

Using Metadata Maps
Metadata maps allow you to provide more detailed information about functions:
(defn ^{:doc "Calculates the total ammunition cost given cost per unit and quantity."
        :added "1.0"
        :author "Cosmo"}
  total-ammo-cost [ammo-cost number-of-units]
  (* ammo-cost number-of-units))
Why It Matters
Adding documentation and metadata to your functions makes your code more readable and maintainable. It helps other developers (and your future self) understand the purpose and usage of each function without diving deep into the implementation. Properly documented code is crucial for effective collaboration, debugging, and future enhancements.

Ready to make your Clojure functions more informative and easier to maintain? Let's dive into the practice section and start enhancing our functions with meaningful documentation and metadata.

Let's take a closer look at the defn macro syntax we are already familiar with:
(defn function-name
  doc-string?       ; ? indicates that these parameters are optional
  metadata-map?
  [parameter-list*]
  conditions-map?
  body-expressions*)
So far, we've created basic functions without using the optional parameters doc-string?, metadata-map?, and conditions-map?. Today, we'll focus on the doc-string? parameter to add documentation to our functions, making it accessible to other developers.

The code snippet in the IDE illustrates how to define a function with a docstring and how to access this documentation using the doc macro:
(require 'clojure.repl)

(defn calculate-hero-damage
  "Calculates a hero's damage output based on base damage and critical multiplier."
  [base-damage critical-multiplier]
  (* base-damage critical-multiplier))

(println "calculate-hero-damage documentation:")
(clojure.repl/doc calculate-hero-damage)
The doc macro is typically executed from the REPL. When using it within a script, you need to add a require statement for clojure.repl to ensure it works correctly.

It's important to note that standard Clojure functions come with extensive documentation that can be easily accessed via the Clojure REPL. When using REPL, a require statement for clojure.repl is not required. To start the REPL, type clojure in your terminal. You can use the REPL to check the docstrings of standard Clojure functions. For example, try typing any of the following commands and pressing "Enter":
(doc map)
(doc reduce)
(doc filter)

;;
(require 'clojure.repl)

;; Defining functions with docstrings

(defn calculate-hero-damage
  "Calculates the hero's damage output.
  Takes two arguments:
  - base-damage: The base damage value of the hero.
  - critical-multiplier: The multiplier applied when a critical hit is scored.
  Returns the total damage output by multiplying base damage with the critical multiplier."
  [base-damage critical-multiplier]
  (* base-damage critical-multiplier))

(defn total-ammo-cost
  "Calculates the total ammunition cost.
  Takes two arguments:
  - ammo-cost: The cost of one unit of ammunition.
  - number-of-units: The total number of units of ammunition.
  Returns the total cost by multiplying the cost per unit with the number of units."
  [ammo-cost number-of-units]
  (* ammo-cost number-of-units))

(clojure.repl/doc calculate-hero-damage)
(clojure.repl/doc total-ammo-cost)

(require 'clojure.repl)

(defn hero-defense 
"Calculates hero's defense.
Arguments: 
  base-defense (number): The hero's innate defense value.
  shield-defense (number): Additional defense provided by the hero's shield.
Returns:
  number: The total defense value, which is the sum of base-defense and shield-defense."
  
  [base-defense 
   shield-defense 
   ]
  (+ base-defense shield-defense))

(clojure.repl/doc hero-defense)


Metadata is a map of data about a Clojure construct (like a function) that does not affect its runtime behavior. Instead, it provides insights into aspects such as documentation, versioning, and authorship.You can attach metadata to functions using a metadata map with the ^{} syntax and read metadata using the meta function:
(defn ^{:added "1.0"
         :author "Cosmo"}
  multiply [a b]
  (* a b))

(println "multiply metadata:" (meta #'multiply))
By the way, a docstring is just syntax sugar for the :doc metadata field. In reality, docstrings are converted to the :doc metadata field.

Now that you know how to attach metadata to functions, run the provided code to see metadata in action. Note that the metadata of the calculate-hero-damage function contains the :doc field with the function docstring.


Clojure Program Flow

Understanding Conditionals
Welcome back! You're about to dive into an essential part of controlling the flow of your Clojure programs: conditionals. You have built a foundation with the basics of Clojure, and now we are going to expand on that by learning how to make decisions within your programs. This will help you add logic and control, making your programs more robust and dynamic.

What You'll Learn
Conditionals allow you to execute different pieces of code based on whether certain conditions are true or false. This unit will cover various forms of conditional expressions in Clojure:

if: Executes a block of code if a condition is true, and another block if it's false.
if-not: Executes a block of code if a condition is false, and another if it's true.
cond: Allows for multiple conditions and corresponding actions.
when: Executes a block of code only if a condition is true.
when-not: Executes a block of code only if a condition is false.
We'll apply these conditionals using a simple example involving a hero's health status in a game.

Unit Outcomes Preview
Here's a quick peek at what you'll be able to do after completing this unit:
(def hero-health 80)

(if (> hero-health 50)
  (println "Hero is in good shape!")
  (println "Hero needs healing!"))

(if-not (> hero-health 50)
  (println "Hero needs healing!")
  (println "Hero is in good shape!"))

(cond
  (> hero-health 75) (println "Hero is in excellent shape!")
  (> hero-health 50) (println "Hero is in good shape!")
  (> hero-health 25) (println "Hero is in poor shape!")
  :else              (println "Hero needs immediate healing!"))

(when (> hero-health 50)
  (println "Hero is in good shape!"))

(when-not (> hero-health 50)
  (println "Hero needs healing!"))

In this example, the message changes based on the value of hero-health. Note that this example uses comparison operators like (>) to evaluate conditions; these will be covered in depth later in this course.

Why It Matters
Mastering conditionals is crucial because they enable your program to make decisions, adding dynamic behavior based on different inputs and states. For instance, imagine a game's hero whose health can vary. By using conditionals, you can create different messages based on the hero's health, enhancing user experience and interactivity.

Enhancing your code with conditionals will not only make it smarter but also more flexible. Ready to get started? Let's jump into the practice section.


Conditionals in Clojure help you execute different pieces of code based on whether conditions are true or false. Here are the key constructs you'll see in this task:

if: Executes one block of code if a condition is true, and another block if it's false. The syntax for if is:
(if condition
  then-expression
  else-expression) ; else-expression is optional
  
condition: An expression that returns either true or false.
then-expression: The expression to be executed if the condition is true.
else-expression: (Optional) The expression to be executed if the condition is false.


if-not: Similar to if, but it checks if the condition is false first. The syntax for if-not is:
(if-not condition
  then-expression
  else-expression) ; else-expression is optional

condition: An expression that returns either true or false.
then-expression: The expression to be executed if the condition is false.
else-expression: (Optional) The expression to be executed if the condition is true.

Here's the syntax for cond:
(cond
  condition1 expression1
  condition2 expression2
  :else default-expression)
condition1: An expression that returns either true or false.
expression1: The expression to be executed if condition1 is true.
condition2: An expression that returns either true or false.
expression2: The expression to be executed if condition2 is true.
default-expression: The expression to be executed if none of the other conditions are true (optional but recommended).

The do form in Clojure is used to group multiple expressions so that they can be executed sequentially. This is necessary when you want to execute more than one expression inside a conditional block like if or when. Without the do form, only the first expression would be executed.
Here’s a quick example:
(if (= 1 1)
  (do
    (println "This is the first expression.")
    (println "This is the second expression.")))
In the code above, both print statements are executed when the condition is true, thanks to the do form.

Exploring Logical Functions
Welcome to the next step in your Clojure journey! In this unit, you'll explore logical functions—key tools that will help you control your program flow with precision. You've already learned how to make decisions in your code using conditionals. Now, we will build on that foundation by diving into logical functions, enabling you to handle more complex logic in your programs.

What You'll Learn
Logical functions in Clojure allow you to combine and manipulate boolean values, making your decision-making processes even more powerful. In this lesson, you'll learn about the following logical functions:

and: Returns true if all conditions are true.
or: Returns true if at least one condition is true.
not: Inverts the value of a condition.
These functions provide a way to streamline and refine the flow of your programs, giving you better control over decision-making processes.

Why It Matters
Logical functions are essential for creating more flexible and robust applications. By mastering them, you can handle complex logical conditions with ease, write cleaner code, and reduce redundancy. For example, in game development, you might need to determine multiple states and actions based on player health, items collected, or enemy states. Logical functions make such tasks straightforward and efficient.

Here is a sneak peek at what you'll learn to do:
(println (and true false)) ;; false
(println (and true true))  ;; true

(println (or true false))  ;; true
(println (or false nil))   ;; nil

(println (not true))       ;; false
(println (not nil))        ;; true
By understanding and applying these logical functions, you'll enhance your capability to create dynamic, responsive, and efficient programs. Ready to gain this vital skill? Let's jump into the practice section and delve into logical functions together!


Logical operators in Clojure help you control the flow of your program by combining multiple conditions. This task will focus on the and operator. The and operator in Clojure evaluates multiple expressions and returns the first falsy value it encounters (nil or false are the only two falsy values in Clojure). If all values are truthy, it returns the last value.
Here’s the syntax for using and:
(and expr1 expr2 expr3 ...)
expr1, expr2, expr3, ...: Expressions that are evaluated in order. If any of these expressions return nil or false, and short-circuits and returns that value. If all expressions are truthy, and returns the last expression.

;; Using and operator

(println "Examples of using the 'and' operator:")

;; Example 1: Combines true and false
(println (and true false)) ;; false

;; Example 2: Combines true and true
(println (and true true)) ;; true

;; Example 3: Combines true, a non-zero number (truthy), and another truthy value
(println (and true 42 :x)) ;; :x

;; Example 4: Combines values including nil (falsy)
(println (and :a nil :b)) ;; nil

;; Example 5: Combines values including false (falsy)
(println (and :a false :b)) ;; false

;; Example 6: No arguments
(println (and)) ;; true

;; Example 7: Combines an empty string (truthy in Clojure) and a zero (truthy)
(println (and "" 0)) ;; 0

The or operator in Clojure evaluates multiple expressions and returns the first truthy value it encounters. If all values are falsy (nil or false), it returns the last value. If there are no expressions, it returns nil.

Here’s the syntax for using or:
(or expr1 expr2 expr3 ...)
expr1, expr2, expr3, ...: Expressions that are evaluated in order. If any of these expressions return a truthy value, or short-circuits and returns that value. If all expressions are falsy, or returns the last expression. If there are no expressions, or returns nil.


;; Using or operator

(println "Examples of using the 'or' operator:")

;; Example 1: Combines true and false
(println (or true false)) ;; true

;; Example 2: Combines nil and a truthy value
(println (or nil 42)) ;; 42

;; Example 3: Combines multiple falsy values
(println (or false nil)) ;; nil

;; Example 4: Combines values including a truthy string
(println (or nil "" :x)) ;; ""

;; Example 5: Combines values where the first one is truthy
(println (or :a false :b)) ;; :a

;; Example 6: No arguments
(println (or)) ;; nil

;; Example 7: Combines values where the last one is truthy
(println (or nil nil 42)) ;; 42

The not function is used to invert the boolean value of its argument. If the argument is truthy (anything that is not false or nil), not returns false. If the argument is falsy (false or nil), not returns true. It ensures the return value is always explicitly boolean.

Here’s the syntax for using not:
(not expr)
expr: The expression whose boolean value you want to invert. If expr is truthy, not will return false. If expr is falsy, not will return true.

;; Example 1: Inverting true
(println (not true)) ;; false

;; Example 2: Inverting false
(println (not false)) ;; true

;; Example 3: Inverting nil (falsy value)
(println (not nil)) ;; true

;; Example 4: Inverting a number (truthy value)
(println (not 1)) ;; false

;; Example 5: Inverting a string (truthy value)
(println (not "Clojure")) ;; false

Exploring Comparison and Equality Functions
Welcome back! Now that you have a solid grasp of logical functions, it's time to explore another vital aspect of programming in Clojure — comparison and equality functions. These are integral for making accurate decisions within your code. By building on the knowledge of conditionals and logical functions you already have, you'll be able to perform precise comparisons and check for equality effortlessly.

What You'll Learn
In this lesson, you will become proficient in using comparison and equality functions, enabling you to write more nuanced and sophisticated Clojure programs. Specifically, you'll learn about:

< (Less Than): Compares numbers to check if the sequence is in ascending order.
> (Greater Than): Compares numbers to check if the sequence is in descending order.
<= (Less Than or Equal To): Verifies if each number in a sequence is less than or equal to the following number.
>= (Greater Than or Equal To): Verifies if each number in a sequence is greater than or equal to the following number.
= (Equality): Checks if multiple values are identical.
== (Numeric Equality): Verifies numeric equivalency across different types.
Understanding these functions is crucial for tasks such as sorting data, validating user inputs, and much more.

Unit Outcomes Preview
Here is a glimpse of what you'll be able to do after completing this unit:
;; Using < (works with any number of arguments)
(println (< 1 2))               ;; true
(println (< 1 2 3 4))           ;; true
(println (< 1 2 2))             ;; false

;; Using = (works with any number of arguments)
(println (= 1 1))               ;; true
(println (= 1 1 1))             ;; true
(println (= 1 2))               ;; false

;; Single equals (=) vs Double equals (==)
(println (= 1 1/1 1N))          ;; true (all are equal)
(println (= 1 1.0M))            ;; false (different types)
(println (= 1/2 0.5))           ;; false (ratio vs floating point)

(println (== 1 1.0M 1.0 1))     ;; true (numerically equal)
(println (== 1 1.1))            ;; false (different values)
(println (== 1 1))              ;; true (same values)

Why It Matters
Mastering comparison and equality functions is essential for creating accurate and efficient programs. These functions are the building blocks for decision-making in your code. Whether you're developing games, working with data, or building web applications, understanding how to compare and equate values correctly ensures your programs run smoothly and as intended.

Are you excited to enhance your Clojure skills further? Let's dive into the practice section and unleash the power of comparison and equality functions together!

< (Less Than): Checks if numbers are in strictly increasing order.
<= (Less Than or Equal To): Verifies if each number is less than or equal to the next one.
> (Greater Than): Checks if numbers are in strictly decreasing order.
>= (Greater Than or Equal To): Verifies if each number is greater than or equal to the next one.

These functions accept any number of arguments, allowing you to perform versatile comparisons in a single expression. They work similarly to comparison operators in other programming languages but can handle multiple arguments.


The = function is versatile and can compare a wide range of objects, including nil, numbers, strings, and sequences. It is similar to Java's equals method but has broader applicability in Clojure. Unlike Java's equals method, = returns true for many values that do not have the same type as each other. However, = does not always return true when comparing numbers from different categories (e.g., integers, big decimals, floating points).
The == function, on the other hand, is specifically designed for numerical comparisons across different numeric types. It provides more intuitive results when dealing with different numeric categories but is limited to numerical values.
A rule of thumb: if you are certain everything you’re comparing is a number and expect different numeric types, use ==. Otherwise, use =.

(println "Using = for equality")
(println (= 1 1N 1/1))         ;; true (all are considered equal as integers/ratios)
(println (= 1 1.0M))           ;; false (different types: integer vs big decimal)
(println (= 1/2 0.5))          ;; false (different types: ratio vs floating point)
(println (= 0.5M 0.5))         ;; false (different types: big decimal vs floating point)
(println (= 0.5M 1/2))         ;; false (different types: big decimal vs ratio)
(println (= "hello" "hello"))  ;; true (same strings)
(println (= [1 2 3] [1 2 3]))  ;; true (same sequential collections)
(println (= nil nil))          ;; true (both are nil)
(println (= nil false))        ;; false (nil and false are not the same)

(println "\nUsing == for numerical equality")
(println (== 1 1N 1/1))        ;; true (all are numerically equal)
(println (== 1 1.0M))          ;; true (numerically equal despite different types)
(println (== 1/2 0.5M 0.5))    ;; true (all represent the same numeric value)
(println (== 2.0M 1.9999999999999999))    ;; true (numerically very close values)


Reminder: In Clojure, maps are key-value pairs and you can access elements using the syntax (:key map), (get map :key), or (map :key). For example, (:name warrior), (get warrior :name), or (warrior :name) fetches the name of the warrior.

;; Warrior and Dragon attributes
(def warrior {:name "Aric the brave" :health 150 :mana 75})
(def dragon {:name "Emerald Wyrm" :status "watchful" :health 150 :mana 65})

;; This condition should evaluate to true and print "Warrior is at full strength"
(when (== (:health warrior) 150.0M)
  (println "Warrior is at full strength"))

;; This condition should evaluate to false and should not print anything
(if (= (:status dragon) "hostile")
  (println "Prepare for battle!"))

(cond
  ;; This condition should evaluate to false and should not print anything
  (= (:status dragon) "hostile") (println "Prepare for battle!")
  ;; This condition should evaluate to true and print "Stay vigilant"
  (= (:status dragon) "watchful") (println "Stay vigilant")
  ;; This should not be executed
  :else (println "Remain on guard"))

Welcome to Functional Iteration in Clojure
We’re moving forward in our Clojure journey! In this lesson, we'll explore functional iteration — a crucial part of programming that involves repeating actions. You've already learned how to make decisions using conditionals and logical functions. Now, you'll see how to handle repetitive tasks elegantly and efficiently in Clojure.

What You'll Learn
Functional iteration allows you to repeat a set of instructions, either based on a specific condition or a set number of times. This is essential for a variety of tasks, such as processing data or controlling game mechanics. In our lesson, you will learn about:

Using while loops: A method for repeating actions until a condition is met.
Using loop and recur: Powerful ways to create loops that are optimized for recursion.
Here's a sneak peek of what we’ll be coding together:
;; Looping with loop/recur in a shooter game
(def max-bullets 5)

(loop [bullets-fired 0]
  (when (< bullets-fired max-bullets)
    (println "Bullet fired! Bullets fired so far:" bullets-fired)
    (recur (inc bullets-fired))))

;; Simulating a shooter game reloading mechanism with a while loop
(def max-bullets 5)
(def bullets 0)

(while (< bullets max-bullets)
  (println "Bullet fired! Bullets remaining in magazine:" (- max-bullets bullets 1))
  (def bullets (inc bullets)))

Why It Matters
Mastering functional iteration is like adding a new tool to your programming toolbox. It enables you to automate repetitive tasks and manage data more efficiently. Whether you're writing a game or processing large datasets, being adept at iteration will save you time and improve your code's accuracy and readability.

By the end of this lesson, you’ll be able to create robust, efficient loops that handle a variety of tasks in your programs. Exciting, right? Let’s dive into the practice section and master functional iteration together!

Clojure’s while macro functions similarly to those in imperative languages like Ruby and Java. The general form is:
(while test & body)
test: An expression evaluated before every loop iteration. If it evaluates to true, the loop continues; if it evaluates to false or nil, the loop stops.
body: One or more expressions that will be repeatedly executed as long as test evaluates to true.
Keep in mind that although while is available, it is less common in functional programming because it relies on side effects and mutable state.

(def shooter-queue ["Reload" "Fire" "Hit" "Reload" "Miss"])

;; TODO: Write a while loop that prints each item in the shooter-queue
;; while there are still messages in the queue.
;; Use `not` with `empty?` to check if the queue still has items.
;; Use `first` to retrieve the current item, and `rest` to update the queue.
(while (not (empty? shooter-queue))
  (println "Action:" (first shooter-queue))
  (def shooter-queue (rest shooter-queue)))

(loop [bindings] & body)
loop sets up bindings similarly to the let form. These bindings are local to the loop's body. For example:
(loop [bullets-remaining 5]
  ;; body of the loop
)
In this example, bullets-remaining is initialized to 5.

The recur form is used within the body of a loop to recursively re-bind the variables and re-enter the loop:
(recur (dec bullets-remaining))

(loop [bullets-remaining 5]
  (when (pos? bullets-remaining)
    (println "Bullet fired! Bullets remaining:" bullets-remaining)
    (recur (dec bullets-remaining))))

The loop initializes bullets-remaining to 5.
Inside the loop, a when condition checks if bullets-remaining is positive (pos?).
If the condition is true, it prints a message indicating a bullet was fired and shows the remaining bullets.
The recur form then decrements bullets-remaining by 1 and re-enters the loop with the updated count.
This process repeats until bullets-remaining reaches 0 and the when condition fails, exiting the loop.

In Clojure, recur can only be used in a tail-call position. If recur is not in the proper position, the compiler will throw an error. A call is in the tail position if the caller returns the value of the recursive call directly. For example, the recursive call to recur (dec x) is in the tail position because it directly returns this value and does nothing else. On the other hand, if we said (do (recur (dec x)) (println x)), recur would no longer be in the tail position because there is still work to do (printing) after recur returns its result.

If all recursive calls made in a function are in the tail position, Clojure optimizes the recursion to iterative loops that do not consume call stack frames for each iteration. For example:
(loop [x 10]
  (if (pos? x)
    (do
      (println x)
      (recur (dec x))) ; recur is in the tail-call position
    (println "Done")))

In this snippet, recur (dec x) is in the tail-call position because it is the last operation inside the if block.

Here is an example where recur is not in the tail-call position:

(loop [x 10]
  (if (pos? x)
    (do
      (recur (dec x)) ; recur is not in the tail-call position
      (println x))
    (println "Done")))

In this snippet, recur (dec x) is not in the tail-call position because (println x) is executed after the recur call within the same block.

Deepening Our Understanding of Function Iteration
Welcome back! You've already begun your journey with functional iteration, learning about loop, recur, and while. Now, let's expand on those concepts by diving into new, powerful tools: doseq and dotimes. These forms of iteration can make your code more concise and efficient, especially when working with collections and repetitive tasks.
What You'll Learn
In this lesson, we'll focus on two primary iteration constructs:

doseq: This is useful for iterating over collections. It allows you to go through each element and perform an action on it.
dotimes: This is excellent for repeating an action a specific number of times. It's simple yet powerful in scenarios where you need fixed iterations.
For example, in a game scenario, you might use these constructs to simulate actions like shooting targets or reloading a weapon. Check out this sneak peek:

(doseq [target ["Target 1" "Target 2" "Target 3"]]
  (println "Shooting" target))

;; Output:
;; Shooting Target 1
;; Shooting Target 2
;; Shooting Target 3

(dotimes [n 3]
  (println "Reloading weapon, iteration:" n))

;; Output:
;; Reloading weapon, iteration: 0
;; Reloading weapon, iteration: 1
;; Reloading weapon, iteration: 2

Why It Matters
Understanding and using doseq and dotimes will enable you to write cleaner, more efficient code. Iteration is a fundamental part of many programming tasks, from data processing to game mechanics. By mastering these constructs, you'll improve your ability to automate tasks, manage resources, and handle repetitive actions with ease.

Ready to enhance your coding skills even further? Let's proceed to the practice section and explore these tools in action.

The doseq macro is used to iterate over each element in a collection and perform an action on each element. The general syntax for doseq is:

(doseq [item collection]
  (action item))
Here:

item is the variable that will take on the value of each element in the collection.
collection is the collection (like a list, vector, or sequence) over which we are iterating.
action is the operation we want to perform for each element.
For example:


(doseq [x [1 2 3]]
  (println "Number:" x))
If you want to perform several actions within the doseq loop, you don't need to use the do form. The doseq macro accepts multiple expressions directly. Here's an example:


(doseq [x [1 2 3]]
  (println "Number:" x)
  (println "Square:" (* x x)))

The doseq loop accepts the body as a vararg, which means you don't need a do form to execute multiple expressions within the loop body. Here’s a reminder of the basic syntax of doseq:

(doseq [item coll]
  expr1
  expr2
  ...)

;; Sequence of game actions
(def game-actions ["fire" "reload" "fire" "fire"])

;; Initial amount of ammo
(def remaining-ammo 10)

;; Function to update ammo
(defn update-ammo [ammo action]
  (cond
    (= action "fire") (max 0 (dec ammo))
    (= action "reload") (min 10 (+ ammo 1))
    :else ammo))

;; Using doseq to iterate over game-actions
(doseq [action game-actions] 
  (println "Performing action:" action)
  (def remaining-ammo (update-ammo remaining-ammo action))
  ;; TODO: Update the remaining-ammo by calling update-ammo with the current remaining-ammo and action, and assign the result to the remaining-ammo variable
  (println "Updated ammo:" remaining-ammo)
  ;; TODO: Print "Updated ammo: <remaining-ammo>" where <remaining-ammo> is the updated ammo count
  )

The dotimes macro is used for repeating an action a specified number of times. Here's the basic syntax:

(dotimes [n count]
  (action n))
Where:

n is the variable iterating from 0 to count - 1.
count is the total number of iterations.
action is the operation performed in each iteration.
For example:

(dotimes [i 3]
  (println "Iteration number:" i))
If you need to perform multiple actions within the dotimes loop, no need to use the do form; you can simply list the expressions:

(dotimes [i 3]
  (println "Iteration number:" i)
  (println "Square of iteration number:" (* i i)))

Exploring Advanced Iteration Functions
Welcome back! You're on an exciting journey in mastering Clojure's iteration techniques. So far, you've gotten comfortable with doseq and dotimes to iterate over collections and perform repeated tasks. Now, we'll elevate your iteration skills by diving into some of Clojure’s most powerful functions: map, filter, remove, and reduce.

What You'll Learn
In this lesson, you will explore four critical functions for functional iteration:

map: Applies a function to each item in a collection and returns a new collection with the results.
filter: Selects items from a collection that meet a specified condition.
remove: Excludes items from a collection that meet a specified condition.
reduce: Aggregates values from a collection using a specified function.
For instance, imagine you are working on a shooter game, and you need to manage enemy health. These functions can help you double health values, filter out weak enemies, remove certain enemies, and calculate the total health of all enemies. Here's a sneak peek:

(def enemy-healths [100 80 60])

;; Using `map` to apply a function to each item in a collection
(def doubled-healths (map #(* 2 %) enemy-healths))
(println "Doubled enemy healths:" doubled-healths) ;; (200 160 120)
;; #(* 2 %) is an anonymous function (also called a lambda) that multiplies its input by 2.

;; Using `filter` to select items based on a condition
(def alive-enemies (filter #(> % 50) enemy-healths))
(println "Alive enemies with health > 50:" alive-enemies) ;; (100 80 60)

;; Using `remove` to exclude items based on a condition
(def weak-enemies (remove #(>= % 80) enemy-healths))
(println "Enemies with health < 80:" weak-enemies) ;; (60)

;; Using `reduce` to aggregate values
(def total-health (reduce + enemy-healths))
(println "Total health of all enemies:" total-health) ;; 240

Why It Matters
Mastering these advanced iteration functions allows you to write more expressive and concise code. You'll be able to handle collections more effectively, manipulate data with greater flexibility, and perform complex operations with ease. Whether you are processing data or controlling game mechanics, these tools will enable you to create more sophisticated and efficient programs.

Excited to see these functions in action? Let's move on to the practice section and put your new skills to the test!

The map function is most commonly used to transform each element in a collection by applying a given unary function to each element. A unary function is a function that accepts only one argument. By applying this function to each element of the sequence, map returns a new sequence containing the results. However, map can also operate on multiple collections simultaneously, using binary, ternary, or higher-arity functions. For the sake of simplicity, let's focus on unary functions for now.

The general syntax for map is:

(map function collection)
Here:

function is the unary function to be applied to each element of the collection.
collection is the collection (such as a list, vector, or sequence) to be transformed.
For example:

(map inc [1 2 3])
This will return (2 3 4), as the inc function increments each element by 1.

Common predefined unary functions include:

inc - increments a number by 1
dec - decrements a number by 1
negate - returns the negation of a number
str - converts a value to a string
You can also define your own functions to use with map. For example:

(map (fn [x] (* x x)) [1 2 3])
This will return (1 4 9), as each element is squared.

While people typically pass a unary function to map, Clojure does allow the use of map with binary or ternary functions, but we'll cover that in one of the next exercises.

;; Transforming collections with map in a shooter game

(def scores [10 20 30])

;; Using map with a predefined unary function (inc)
(def increased-scores (map inc scores))
(println "Increased scores:" increased-scores) ;; (11 21 31)

;; Using map with a custom function to double the values
(def doubled-scores (map (fn [x] (* 2 x)) scores))
(println "Doubled scores:" doubled-scores) ;; (20 40 60)

;; Using map with a custom function to convert scores to strings
(def string-scores (map (fn [x] (str "Score: " x)) scores))
(println "Stringified scores:" string-scores) ;; ("Score: 10" "Score: 20" "Score: 30")

Here’s a quick reminder: The map function takes a function and one or more sequences, applying the function to each corresponding element of the sequences. For example:

(map inc [1 2 3]) ;; (2 3 4)
You can define custom unary functions with the fn keyword or with shorthand syntax using #(). For example:

(map (fn [x] (+ x 1)) [1 2 3]) ;; (2 3 4)
(map #(+ 1 %) [1 2 3]) ;; (2 3 4) 

;; TODO: Use the map function to convert each score to a player rank based on the condition:
;; If a player's score is greater than 100, they are a "Pro". Otherwise, they are a "Rookie".
(def player-ranks (map (fn[x] (if (> x 100) (str "Pro") (str "Rookie"))) player-scores))
(println "Player ranks:" player-ranks) ;; Expected Output: ("Rookie" "Pro" "Rookie" "Pro" "Rookie")


The map function transforms elements in one or more collections using a specified function. While we previously discussed using map with unary functions, it can also handle binary, ternary, or higher-arity functions.

The general syntax for map with multiple collections is:

(map function collection1 collection2 ...)
Here:

function is the function to be applied to corresponding elements of the collections.
collection1, collection2, etc., are the collections to be transformed.
Here are some basic examples:

Using map with a binary function:

(map + [1 2 3] [4 5 6]) ;; (5 7 9)
Using map with a ternary function:

(map (fn [a b c] (+ a b c)) [1 2 3] [4 5 6] [7 8 9]) ;; (12 15 18)
Defining custom functions:

(map (fn [a b] (* a b)) [1 2 3] [4 5 6]) ;; (4 10 18)
When the sizes of collections are uneven, map stops processing as soon as the shortest collection is exhausted:

(map + [1 2 3] [4 5 6 7 8]) ;; (5 7 9)

 filter and remove. These functions allow you to selectively include or exclude elements in a collection based on a predicate function.

filter Function

The filter function returns a collection of elements that satisfy a predicate function.
A predicate function is one that returns either true or false for a given item.
General syntax:
(filter predicate collection)
predicate: the function that evaluates each item. If it returns true, the item is included in the result.
collection: the collection (such as a list, vector, or sequence) to filter.
For example:

(filter odd? [1 2 3 4 5])
;; This will return (1 3 5), as only the odd numbers are included.
remove Function

The remove function is similar to filter but it returns a sequence of elements that do not satisfy the predicate function.
General syntax:
(remove predicate collection)
predicate: the function that evaluates each item. If it returns false, the item is included in the result.
collection: the collection to filter.
For example:

(remove even? [1 2 3 4 5])
;; This will return (1 3 5), as only the odd numbers are included (same as using `filter odd?`).
A few in-built predicates:

odd?: checks if a number is odd.
even?: checks if a number is even.
pos?: checks if a number is positive.
neg?: checks if a number is negative.

;; Managing enemy health with filter and remove in a shooter game

(def enemy-healths [100 80 60 40 20])

;; Using filter to select enemies that are still alive (health > 50)
(def alive-enemies (filter #(> % 50) enemy-healths))
(println "Alive enemies with health > 50:" alive-enemies) ;; (100 80 60)

;; Using remove to exclude enemies that are weak (health <= 50)
(def weak-enemies (remove #(<= % 50) enemy-healths))
(println "Weak enemies (health > 50):" weak-enemies) ;; (100 80 60)

;; Another example: Using filter to find positive health enemies
(def positive-health-enemies (filter pos? enemy-healths))
(println "Positive health enemies:" positive-health-enemies) ;; (100 80 60 40 20)

;; Another example: Using remove to exclude enemies with positive health (everyone in this case)
(def non-positive-health-enemies (remove pos? enemy-healths))
(println "Non-positive health enemies:" non-positive-health-enemies) ;; ()

;; TODO: Use the filter and remove functions together to keep players with scores 
;; 80 or more, but eliminate those with 180 or more.
(def specific-scorers (filter #(>= % 80) (remove #(>= % 180) player-scores)))
(println "Specific scorers:" specific-scorers) ;; Expected Output: (120 85)

The reduce function is used to aggregate elements of a collection into a single result by successively applying a given binary function to the elements. A binary function is a function that accepts two arguments. The general syntax for reduce is:

(reduce function initial-value collection)
(reduce function collection) ;; when no initial-value is provided
Here:

function is the binary function to be applied to the elements of the collection.
initial-value is the optional starting value for the aggregation.
collection is the collection (such as a list, vector, or sequence) to be reduced.
For example:

(reduce + 0 [1 2 3 4])
This will return 10, as the + function is successively applied to the elements of the list starting with 0.

If the initial-value is omitted:

(reduce + [1 2 3 4])
This will also return 10, starting the reduction with 1.

Common predefined binary functions include:

+ - sums two numbers
* - multiplies two numbers
max - returns the maximum of two numbers
min - returns the minimum of two numbers
You can also define your own functions to use with reduce. For example:

(reduce (fn [acc x] (* acc x)) 1 [1 2 3 4])
This will return 24, as each element is multiplied with the accumulator starting with 1.

;; Aggregating collections with reduce in a shooter game

(def healths [100 80 60])

;; Using reduce with a predefined binary function (+)
(def total-health (reduce + 0 healths))
(println "Total health of all enemies:" total-health) ;; 240

;; Using reduce with a custom function to find the maximum health
(def max-health (reduce max healths))
(println "Maximum health of all enemies:" max-health) ;; 100

;; Using reduce with a custom function to build a string summary
(def summary (reduce (fn [acc x] (str acc ", " x)) "Health values:" healths))
(println summary) ;; "Health values:, 100, 80, 60"

(def enemy-hit-points [10 20 30 40 50])
;; TODO: Use the reduce function to calculate the hit points combo with bonuses
(def hit-points-combo
  ;; We start with an initial value of 50 and for each hit point we add the hit point value plus a bonus of 10
  (reduce (fn [acc x](+ acc x 10)) 50 enemy-hit-points)
)